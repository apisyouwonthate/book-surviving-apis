= Form Generation

Imagine you're building a shiny new web app which requires users to register an account with a profile that includes their mailing address.  You're using https://stripe.com[Stripe] for payments, and because of that, you're forced to limit registrations to the https://stripe.com/global[countries supported by Stripe].  Looking at their list on launch day, you see that they support _34 Countries_:

.Stripe's list of supported countries on day 1 of your product launch
image::images/form-generation-stripe-countries.png[]

Taking note of that list, you build out your HTML form with a `<select>` box that has an entry for each country:

[source,html]
----
<select>
  <option value="australia">Australia</option>
  <option value="austria">Austria</option>
  <option value="belgium">Belgium</option>
  <option value="canada">Canada</option>
  <!-- etc -->
</select>
----

Having done that, you let the product out into the world.  Maybe you make a mental note to check back on Stripe's list of supported countries in 6 months - or you do one better and log a ticket in your project tracking system so that it doesn't get forgotten forever.  Even with the best of intentions, if Stripe updates their supported country list down the line, you may miss it for some length of time.  At best, that represents a lost opportunity to gain paying customers in a new geography. But what happens if Stripe _removes_ a country from their list? Suddenly you've got a potentially very broken experience on your hands.  Crap.

In a better world, this is exactly where form generation would start to save your butt. After some googling, you find that Stripe actually has https://stripe.com/docs/api/country_specs/object[an API endpoint] which you can use to grab a list of countries which they support.  It contains all of the metadata you'll need to make decisions about which countries to include in your dropdown list!  Suddenly you've got a solution on your hands which is much more maintainable:

----
// note: this is a simplified example, done with react, for illustration purposes

const countries = await fetch('https://api.stripe.com/v1/country_specs');

const countrySelect = (
  <select>
    {countries.forEach(country => <option key={country.id} value={country.id}>{country.displayName}</option>)}
  </select>
);

// render a select box with a list of countries
return countrySelect;
----

This approach can also save you loads of time when it comes to standardizing your UI.  There's a principle in software development called DRY (Don't Repeat Yourself), which can serve as an easy litmus for front-end developers.  Though the work may not have been incredibly complex, there's quite a bit of repeated code in the first example above. It's easy enough to add another country to that list by creating a new `<option />` tag with a few attributes on it, but once the story gets a little more complex, the work gets lots heavier.

What if your team decided that it was bad form to use the country name as the value of each checkbox, and instead that the value for each needs to be its ISO standard abbreviation? Now you've got to go back and edit each and every country to update its value.  The same goes for relatively common HTML-ish tasks, like adding an `id="blah"` attribute to each element.  

Imagine now that requirements have changed, and that your users now need to indicate _all_ of the markets in which they intend to do business.  Now your `<select>` doesn't make sense, and all of those `<option>` entries need to be turned into something like `<input type="check" />`.  That's a lot of work, and the amount of work grows linearly with each country added to the list.  Not good.

In all of these cases, you'll have to go back and update _each and every_ line of code manually.  Even if you're particularly savvy with your IDE, or are great at find/replace or perl scripting or regex or whatever it may be, you're opening yourself up to an error-prone and change-intensive process, which could be saved if you better encapsulated your interface with components or partials or includes, or whatever your implementation of choice makes available to you.

----
// country list implemented as a select dropdonw
const CountryEntry = ({ country }) => (
  <option value={country.id}>{country.displayName}</option>
);

const CountryList = ({ countries }) => (
  <select>
    {countries.forEach(country => (
      <CountryEntry
        key={country.id}
        country={country}
      />
    )}
  </select>
);
----

----
// country list implemented as checkboxes
const CountryEntry = ({ country }) => (
  <input
    type="checkbox"
    value={country.id}
  >
    {country.displayName}
  </input>
);

const CountryList = ({ countries }) => (
  {countries.forEach(country => (
    <CountryEntry type="checkbox"
      key={country.id}
      country={country}
    />
  )}
);
----

== JSON Schema

In the chapter on Validation, we discussed how JSON Schema can be used to keep form validation in tune with your API's validation rules. From a usability standpoint, using JSON Schema for validation alone can represent a massive leap in progress compared to old-world application development.  As JSON Schema can _also_ be used to generate your app's input forms. 

