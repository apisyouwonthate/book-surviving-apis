{\rtf1\ansi\ansicpg1252\cocoartf1671
\stshfdbch0{\fonttbl\f0\froman\fcharset0 Palatino-Roman{\*\falt Palatino};\f1\froman\fcharset0 Palatino-Bold{\*\falt Palatino Bold};\f2\fnil\fcharset0 Menlo-Regular{\*\falt Menlo Regular};
\f3\froman\fcharset0 Palatino-Italic{\*\falt Palatino Italic};}
{\colortbl;\red255\green255\blue255;}
{\stylesheet {\s0 Normal;}{\s1 \tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sb260\pardirnatural\partightenfactor0\b\fs36\cf0\outlinelevel1 Heading 1;}{\s2 \tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\li720\fi-720\pardirnatural\partightenfactor0\fs22\cf0 Code Block;}}
{\*\expandedcolortbl;;}
{\info
{\author Phil Sturgeon}
{\creatim\yr2018\mo1\dy26\hr1\min4\sec15\timesinceref538617855}
{\revtim\yr2018\mo1\dy30\hr1\min6\sec26\timesinceref538963586}}\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\fs26 \cf0 There is one more piece of theory we need to get our heads around to really understand the differences between these API paradigms/concepts. In couples dancing there is usually one person leading, and another person following. The leader will be in charge of signaling when moves should be made, and the follower follows their hints. In REST the idea is that the server leads. In all forms of RPC (including GraphQL), the client leads.\
We already spoke about REST \'93normalizing state\'94, which is the concept of removing the guesswork and decision making on things that the server is authoritative on.  The client application in a REST API becomes a thin UI, which handles user interactions, forms, validations, rendering, animations, but very little business logic. That is the theory anyway. A lot of RESTish/RPC/GraphQL APIs force the clients to figure out things they should not be trying to figure out, as their main interest is trying to send as little data as possible. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\s1
\f1\b\fs36 \cf0 Inferring State from Arbitrary Fields\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\b0\fs26 \cf0 At the day job, an upstream API decided originally suggested that clients should check for `location_uuid == nil` to infer the membership type as an \'93Anywhere member\'94 (a member who can access any of our coworking specs. One day they changed the logic, suggesting clients check for location_uuid == \'93some-special-uuid\'94. This was not communicated to the developers in charge of various systems as nobody remembered which of the 50+ systems were making the check. One outcome of that was to confuse the permissions API, which started denying things it should not have been denying. Who even knows what else broke and what else was fixed by various teams working on various systems. Applications need to be investigated, fixed, and updated.\
Inferring meaning from arbitrary fields can lead to production issues, angry users, and wasted developer time debugging bizarre things. The preferred approach in many of these situations would be to have the current state normalized on the server with a simple field like \'93type\'94 which could have a few options like \'93anywhere\'94, \'93other\'94, and the API can figure out when to display that. If the API you are working with asks you to infer state of some random fields, politely let them know that you don\'92t want their laziness to break your client application. Request they provide their data in a useful generic fashion, so the clients don\'92t need to guess everything.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\s1
\f1\b\fs36 \cf0 Available Actions\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\b0\fs26 \cf0 Working out the current state is bad enough, but working out what to do \'93next\'94 when you have a record can be really tough. For example, a ReactJS application at work had loads of awful helper functions to work out which \'93actions\'94 to show next to a list of users in a company (through the joining resource known as seats).\
\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\li720\fi-720\pardirnatural\partightenfactor0

\s2
\f2\fs22 \cf0 IsNotPrimaryOfAnotherCompany(user, company_uuid) \{\
  return _(user.data.result.seats).select(s => \{\
    return s.company.uuid != company_uuid &&\
    s.status == "active" &&\
    s.kind == "Licensee" &&\
    s.company.status == "active";\
  \}).isEmpty();\
\},\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
\s0
The users and company resources have status, and seats has a kind, so this is somewhat ok, but the client is still working really hard for this seemingly complex, but potentially simple functionality. Business logic states that users should not be primary members of more than one company at the time, so a rule was made in the user management interface to hide the \'93Make Primary Member\'94 option if they were. That seems reasonable enough, but when the iOS native codebase forgot to add that `s.status == "active\'94;` condition, the two devices were showing different actions. We fixed it on iOS, and a few months later another rule was added to the JavaScript code, causing an unexpected difference that regression tests did not catch\'85 
\f3\i \

\f0\i0 The \'93skinny server, fat client\'94 approach is forcing the client to download all the seats, and the user information, and the company, just to spin through all the records and establish if the user can or cannot see a \'93Make Primary Member\'94 button\'85 \
The most basic thing to do for RPC would be to make a \'93can_be_promoted\'94 boolean field, which would contain all of the logic internally. The API is a far better at handling this, it\'92ll do it more performantly, and it will be able to change its own ruling internally whilst still communicating the same meaning. Try requesting that from the API developers, and who knows you might get lucky. The REST approach would be to normalize hypermedia controls (HATEOAS), to also normalize that state up into the server. If the API was using a format like Siren, you might see a link nicknamed \'93promote\'94 for employees, and \'93demote\'94 for primary members. The client application could then easily be trained to recognize the promote/demote links and show the appropriate buttons. Siren would also handily show the metadata (URI, method, fields, etc.) required for the client to make the change.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\s1
\f1\b\fs36 \cf0 You Cannot Always Be a Skinny Client\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\b0\fs26 \cf0 Neither approach is definitely good or bad in their entirety, it\'92s simply the case that skinny clients have fewer changes of misrepresenting the state if they are given the answers explicitly. Whenever clients try to copy the business logic rules, the chance of different clients inferring things differently increases. Different codebases will guess things differently, some will notice changes and others won\'92t, and the need to deploy multiple clients in unison becomes a lot more common. It also generally leads to having a broken user experience across different devices.\
Letting the server take control of such things can be a little scary, and it also depends on the relationship the client has with the API, the team developing it, and the intent of the client application. If the API is a third-party, letting them lead could cause some unexpected results. If the API was designed without the knowledge of the clients requirements, the API might not do a very good job of leading. }