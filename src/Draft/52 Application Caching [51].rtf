{\rtf1\ansi\ansicpg1252\cocoartf1671
\stshfdbch0{\fonttbl\f0\froman\fcharset0 Palatino-Roman{\*\falt Palatino};\f1\fnil\fcharset0 Menlo-Regular{\*\falt Menlo Regular};}
{\colortbl;\red255\green255\blue255;}
{\stylesheet {\s0 Normal;}{\s1 \tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\li720\fi-720\pardirnatural\partightenfactor0\fs22\cf0 Code Block;}{\*\cs25 \fs22\cf0 Code Span;}}
{\*\expandedcolortbl;;}
{\info
{\author Phil Sturgeon}
{\creatim\yr2018\mo10\dy11\hr3\min6\sec12\timesinceref560912772}
{\revtim\yr2018\mo11\dy1\hr21\min4\sec57\timesinceref562795497}}\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\fs26 \cf0 So you\'92re writing a client application, and you like the idea of skipping duplicate requests for a few reasons. Maybe you want to avoid going over the API rate limit, draining the battery of the mobile device, or avoid going over the wire if you don\'92t have to. All good reasons to look into caching responses.\
At first you might consider application caching. In Rails, using application caching to wrap an API request usually looks a bit like this:\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\li720\fi-720\pardirnatural\partightenfactor0

\s1
\f1\fs22 \cf0 Rails.cache.fetch("users/#\{uuid\}") do\
  UserAPI.find_user(uuid)\
end\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\fs26 \cf0 If there is nothing in the cache with the key {\cs25
\f1\fs22 user/foo} then it will run the code contained in the \'93{\cs25
\f1\fs22 do\'94} block, which calls a method on the SDK and goes over the wire to fetch the thing. That is handy and all, but how long does that cache entry last? The answer is forever! Infinity is a long time, so we have to provide a reasonable expire period.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\li720\fi-720\pardirnatural\partightenfactor0

\s1
\f1\fs22 \cf0 Rails.cache.fetch("users/#\{uuid\}", expires_in: 12.hours.from_now) do\
  UserAPI.find_user(uuid)\
end\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\fs26 \cf0 That is great and all, but the you - the client - providing \'9312\'94 is possibly not something you should be doing, as you do not own the data. If this is an RPC API and you are part of the same team as the folks who made it, you might know enough about the data source to be confident in making this call, but if you do not own the data then picking an arbitrary number is a bad idea.\
Even if 12 is an appropriate number at the time, cache duration could change for a number of reasons. In the most simple case, this leads to \'93My email address is showing up differently in multiple places\'94, but beyond that there may be all sorts of business logic potentially involved with how long data should be cached. \
I\'92ve experienced odd situations where a race condition was causing a resource to fetched immediately after it was created, which would cause it to be cached for 5 hours. An important update would happen a few minutes after creation letting us know what sort of membership the user had. That update was not noticed by the system doing this hard time-based caching for that whole 5 hours. Some folks would set up complex invalidation rules, or say \'93well that data cannot be cached!\'94 but in reality the data could easily be cached after that initial state. We switched from time-based application caching, to using HTTP caching. This allowed the API to define how long the data should be cached for, and the client just does what it\'92s told.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\li720\fi-720\pardirnatural\partightenfactor0

\s1
\f1\fs22 \cf0 expiry_time = model.present? ? 15.minutes : 5.hours\
expires_in(expiry_time, public: true)\
render_json_response :ok, user_memberships if stale?(model){\cs25 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0
\cf0 }
\s0
\f0\fs26 Having the flexibility to let the API tell clients how long to cache things for is really handy, but sounds a lot like magic. Let\'92s take a look at HTTP caching to see how it all works.}