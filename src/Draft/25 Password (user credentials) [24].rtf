{\rtf1\ansi\ansicpg1252\cocoartf1671
\stshfdbch0{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
{\stylesheet {\s0 Normal;}}
{\*\expandedcolortbl;;}
{\info
{\author Phil Sturgeon}
{\creatim\yr2018\mo1\dy3\hr12\min16\sec9\timesinceref536670969}
{\revtim\yr2018\mo1\dy20\hr19\min5\sec42\timesinceref538164342}}\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\sb160\pardirnatural\partightenfactor0

\f0\fs28 \cf0 User Credentials are possibly the easiest way to get an access token for a user. This skips the whole\
redirect flow that 'Authentication Code' provides, and the user peace-of-mind that comes with it, but does\
offer simplicity. If Twitter had offered User Credentials OAuth 2.0 login as a replacement for HTTP Basic, then\
the 'Twitter Authpocolypse' a few years ago would have been far less drastic.\
All you need to do is provide a username and password to the OAuth 2.0 server, and it gives you back an access\
token (and of course maybe a refresh token). Simple.\
An example of this being extremely useful is creating a single page application with\
AngularJS/EmberJS/WhateverJS and wanting to provide a login. Clearly redirecting users around would be\
unnecessary because they are already on "your site", and the login box can be already styled however you like.\
The trouble is, if you try to do all of this in JavaScript code, you run into a problem. You need to send the\
`client_id` and `client_secret` along with the `username` and `password`, but if you are using JavaScript then\
putting your `client_secret` into the JavaScript means it is readable in the browser.\
HACK HACK HACK!\
Do not do that.\
It is easily avoidable; simply make a proxy script that will take a username and password as POST items, then\
pass them onto the OAuth 2.0 server with the `client_id` and `client_secret` too, both of which probably come from\
some secret config file on the server.\
\{title="Basic access token proxy script written in Python using Flask", lang=python\}\
~~~~~~~~\
import requests\
from flask import Flask\
app = Flask(__name__)\
@app.route('/proxy/access_token', methods=['POST'])\
def access_token():\
    payload = \{\
        'grant_type': 'password',\
        'client_id': 'foo',\
        'client_secret': 'bar',\
        'username': request.form['username'],\
        'password': request.form['password']\
    \}\
    r = requests.post('https://oauth.example.org/', data=payload)\
    return r.json(), r.status_code\
~~~~~~~~\
That is all that needs to be done. Take whatever it gives you, pass it onto the server, and pass the response\
back. This keeps the secret information secret and still lets you do everything else in the browser.\
[Section 4.3 in the spec][Section 4.3]}