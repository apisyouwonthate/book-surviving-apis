{\rtf1\ansi\ansicpg1252\cocoartf1671
\stshfdbch0{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
{\stylesheet {\s0 Normal;}}
{\*\expandedcolortbl;;}
{\info
{\author Phil Sturgeon}
{\creatim\yr2018\mo1\dy3\hr12\min16\sec9\timesinceref536670969}
{\revtim\yr2018\mo1\dy20\hr19\min5\sec42\timesinceref538164342}}\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\sb160\pardirnatural\partightenfactor0

\f0\fs28 \cf0 OAuth 2 dropped the secret token, so users are simply getting an _access token_ now. It also dropped signature\
encryption. This was seen by many as a massive step backwards in security, but it was actually rather a wise\
move. The OAuth 1.0a spec made SSL optional, but OAuth 2.0 requires it. Relying on SSL to handle the encryption\
of the request is logical and drastically improves the implementation.\
Even a basic GET request in OAuth 1.0a was horrendous as you would always need to set up your consumers,\
signatures, etc., but with OAuth 2.0 you can simply do this:\
\{lang=php,starting-line-number=1\}\
~~~~~~~~\
file_get_contents('https://graph.facebook.com/me?access_token=vr5HmMkzlxKE70W1y4Mi');\
~~~~~~~~\
Or, as we saw back in [chapter 3](#chapter-3), you can usually pass access tokens to the server as an HTTP\
request header:\
~~~~~~~~\
POST /moments/1/gift HTTP/1.1\
Host: api.example.org\
Authorization: Bearer vr5HmMkzlxKE70W1y4Mi\
Content-Type: application/json\
\{ "user_id" : 2 \}\
~~~~~~~~\
That looks a little easier to work with than OAuth 1.0a, right?\
W> ### Headers vs. URL\
W> You should always try to use the `Authorization` header to send your tokens whenever possible. The query-string is\
W> secured when using SSL, but unless they are intentionally blocked then access tokens could start turning up in server\
W> logs and various other places. Also, browsers will store the full URL (including query-string) in history. This could\
W> easily compromise the integrity of users security if their computer is stolen or if a sibling decides to play a prank.\
**"Short"-life Tokens**\
As discussed, OAuth 1.0a also uses the same tokens essentially forever. OAuth 2.0's access tokens will (can)\
expire after an arbitrary period of time, which is defined by the OAuth server. When you request an access token, you will\
usually be provided with a _refresh token_ and an _expiry offset_, which is the number of seconds until the token\
expires. Some servers send you a unix time at which it expires. Folks like to do things different for some\
reason, but if you know what to look out for it is not so bad.\
Using the expire time you know when your access token will not be valid, so you can proactively create a CRON\
job that refreshes the access tokens, or you can wrap your HTTP requests in an exception handler that looks for\
a 'Not Authorized' error and then refreshes them as the OAuth 2.0 spec recommends.\
This extra "access tokens expire and you have to refresh them" step initially seems confusing and annoying,\
especially when you are used to "once I have this token it works forever". However, it is much more secure. OAuth 1.0a\
stopped you handing out your username and password by essentially giving you another username and password (the\
token and the secret), which worked for one specific client. Any good network admin will tell you that you should\
regularly change your password (at least once every month), and OAuth is no different as the more you use the same\
password/token the greater your chance of somebody finding out what it is.\
**Grant Types**\
One further massive benefit OAuth 2.0 provides over OAuth 1.0a is the ability to have multiple (even custom) grant\
types. Grant types are essentially a "mode" in which the OAuth 2.0 server will run, expecting different inputs and\
maybe providing different outputs. With this flexibility, you can create some amazing implementations.\
The most common OAuth 2.0 Grant Type that a user will be familiar with is `authorization_code`, which is a very OAuth\
1.0a-like flow.\
A client web app creates a link to the OAuth Server of the service they would like to log into (e.g. Facebook), and the\
user logs in. Facebook redirects the user back to the client web app's 'Callback URL' with a `?code=FOO` variable in\
the query string. The web app then takes that code and makes a second request to Facebook (usually a `POST`, but sometimes\
a `GET` depending on which popular API you look at) and Facebook then offers up an access token in the response.\
Some other popular APIs, like Google Apps, then provide `expires` and a refresh token too.\
This is just one approach and there are more. Due to this flexibility, OAuth 2.0 is good for pretty much any\
scenario when authenticating an API, be it a basic username password login on a single-page JavaScript app, a\
CRON job that has no database access, or a full blown user-redirect flow between different websites. The flexibility\
of custom grant types allows absolutely anything to be done.\
More on this in the 'Understanding OAuth 2.0 Grant Types' section below.\
**Erin Hammer**\
Often, I am asked why anyone would still use OAuth 2.0 after Erin Hammer (lead author and editor of the OAuth 2.0\
standard) [withdrew his name from the specification]. It certainly sent a ripple through the Internet, but I\
personally disagree wholeheartedly with the issues he raised.\
1. OAuth 2.0 is less secure if you do not use SSL/TSL. Correct. So use them.\
2. People have implemented OAuth 2.0 badly (looking at you Facebook/Google/most providers), but when implemented well it is lovely. Use a pre-built standard compliant implementation.\
3. He thinks refresh tokens are annoying, but I think they are great.\
His departure from the project is no major loss. I am sure the IETF are bikeshedding hard,\
but after using both for years, I am much happier with OAuth 2.0 and really wish [Twitter would get on with a\
full upgrade] so I never have to use OAuth 1.0a again.\
_Generally speaking,_ OAuth 2.0 is a good fit for a huge majority of situations, provided you **use SSL** and\
implement a **well-tested** existing solution for your OAuth 2.0 Server. Trying to do this yourself can be\
incredibly hard and may well lead to you getting super-hacked. Even Facebook\
have trouble here to this day because they rolled their own solution based on a really early draft of the\
specification.\
[withdrew his name from the specification]: http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/\
[Twitter would get on with a full upgrade]: https://dev.twitter.com/discussions/397}