{\rtf1\ansi\ansicpg1252\cocoartf1671
\stshfdbch0{\fonttbl\f0\froman\fcharset0 Palatino-Roman{\*\falt Palatino};\f1\froman\fcharset0 Palatino-Bold{\*\falt Palatino Bold};\f2\fnil\fcharset0 Cochin-Bold{\*\falt Cochin Bold};
\f3\fswiss\fcharset0 Helvetica;\f4\fnil\fcharset0 Menlo-Regular{\*\falt Menlo Regular};}
{\colortbl;\red255\green255\blue255;}
{\stylesheet {\s0 Normal;}{\s1 \tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sb260\pardirnatural\partightenfactor0\b\fs36\cf0\outlinelevel1 Heading 1;}{\s2 \tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sb260\pardirnatural\partightenfactor0\b\fs26\cf0\outlinelevel2 Heading 2;}{\*\cs25 \fs22\cf0 Code Span;}}
{\*\expandedcolortbl;;}
{\info
{\author Phil Sturgeon}
{\creatim\yr2017\mo11\dy11\hr22\min18\sec57\timesinceref532127937}
{\revtim\yr2018\mo12\dy10\hr4\min50\sec2\timesinceref566106602}}\deftab720
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\pardeftab720\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\fs26 \cf0 Change Management in relation to APIs, is a collective term for making improvements over time. Hopefully the change is handled in a non-breaking fashion, giving you ample time to make necessary changes. \
There are a two main approaches to change.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\pardeftab720\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\b \cf0 Versioning
\f0\b0  - Shoving a version number (v1, v2, v3) next to things, or in some odd cases the version is a date. The version might apply to the entire API (global versioning), or a single resource (resource versioning).\

\f1\b Evolution
\f0\b0  - Instead of versioning the whole API, or specific resources/endpoints, some APIs will instead chose to carefully evolve their interface over time. \
Let\'92s go more in depth into these concepts, and how they come into effect in various API paradigms.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\s1
\f2\b\fs36 \cf0 REST / "Endpoint-based\'94 APIs
\f0\b0\fs26 \
\pard\s1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\f3\fs34 \cf0 <$Scr_H::2>
\f1\b\fs26 Global Versioning\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\pardeftab720\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s2
\f3\b0\fs34 \cf0 <!$Scr_H::2>
\f0\fs26 API endpoints are grouped (essentially \'93namespaced\'93) under a version number, e.g. {\cs25
\f4\fs22 {\field{\*\fldinst{HYPERLINK "https://hostname/v1/companies"}}{\fldrslt https://hostname/v1/companies}}}, to make it clear that a {\cs25
\f4\fs22 /v1/companies} has no relation whatsoever to a {\cs25
\f4\fs22 /v2/companies}.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\pardeftab720\fi360\sl264\slmult1\pardirnatural\partightenfactor0
\s0
\cf0 In {\field{\*\fldinst{HYPERLINK "http://semver.org/"}}{\fldrslt SemVer}} terms, the version number in the URL is a major version. You should expect no breaking changes to occur in this major version, as that would be the job for a new major version. All resources should be copied from the old version to the new version, unless they're being discontinued.\
Most APIs will not bother with minor or patch versions, because minor and patch changes are backwards compatible. Adding new fields to responses, new optional fields to requests or new resources will not break implementations, so that can be done without needing a major version. Changing validation rules, removing fields, or drastic changes to relationships, are things that may require a new major version be created.\
Usually old versions will be maintained for a reasonable timeframe, but what's considered reasonable is completely up to the API maintainers. It could be one month, a year, or anything in between. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\s2
\f1\b \cf0 Evolution\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\pardeftab720\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\b0 \cf0 API evolution is the concept of striving to maintain the \'93I\'94 in API, the request/response body, query parameters, general functionality, etc., only breaking them when you absolutely, absolutely, have to; then when you do, you manage that change with sensible warnings to clients. It\'92s the idea that API developers bending over backwards to maintain a contract, no matter how annoying that might be, is often more financially and logistically viable than dumping the workload onto a wide array of clients. No version numbers exist in the URL, headers, or query string, and no two versions of the same resource will exist at any given time. There is only the \'93current version\'94.\
Just like in global versioning, backwards compatible changes like adding new methods to existing resources, new fields to responses, new optional fields to requests, new resources, etc. These can happen any time, without clients needing to change anything. For example, splitting \'93name\'94 into \'93first_name\'94 and \'93last_name\'94. The \'93name\'94 field would still appear in responses along with the new first_name and last_name fields, and could still be sent. This is a perfect evolution, because nothing broke for the client, and the server supports the new functionality - allowing folks to be specific about their first and last names instead of the server guessing by splitting on space or something silly.\
Where evolution differs from global versioning, is that instead of creating a whole new namespace (forcing clients that don't even use the specific changing resources to update/test code at great time and expense), a single new resource is made to replace the existing resource when adding new fields is not going to cover the use-case. \
For example, a carpooling company that has \'93matches\'94 as a relationship between \'93drivers\'94 and \'93passengers\'94, suggesting folks who could ride together, containing properties like \'93passenger_id\'94 and \'93driver_id\'94. They realized they need to support carpools with multiple drivers (i.e. Frank and Sally both take it in turns to drive), so this whole matches concept is garbage.\
At a lot of startups, this sort of conceptual change is common. No number of new properties is going to help out here, as the whole \'93one record = one match = one driver + one passenger\'94 concept is foiled.\
Deprecating the whole concept of \'93matches\'94, a new concept of \'93riders\'94 is created. This resource tracks folks far beyond just being \'93matched\'94, through the whole lifecycle of the carpool, thanks to a {\cs25
\f4\fs22 status} property containing pending, active, inactive, blocked, etc.\
By creating the {\cs25
\f4\fs22 /riders} endpoint, this resource can have a brand new representation. The API maintainers may well be converting matches to riders - or riders to matches - in the background, but clients don\'92t need to care about that. Clients can then use either one, allowing them the change to upgrade at their own pace.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\s1
\f1\b\fs36 \cf0 GraphQL\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\pardeftab720\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\b0\fs26 \cf0 GraphQL also uses the evolution approach, and this works the same as the REST / "Endpoint-based" API evolution approach. GraphQL APIs following evolution carefully will try to avoid breaking changes, sticking to backwards compatible changes like adding optional fields to mutations and queries, new arguments on fields, new relationships, etc.\
When these backwards compatible changes are not going to be enough to provide the new functionality required, new mutations and new types might be created: just like the matches and riders example above. In another system, maybe a \'93Company\'94 becomes an \'93Account\'94 if that is more appropriate to the constantly changing business language, but maybe Company2 is created if not. This should only be done when the existing type is utterly unable to bend to the new rules of the context, and simply suggesting new fields cannot satisfy requirements.\
Global versioning is not possible in GraphQL. When raised with Facebook the topic was closed with a WONTFIX, so you will not have to worry about that.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\sl264\slmult1\sb260\pardirnatural\partightenfactor0

\s1
\f1\b\fs36 \cf0 gRPC\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\pardeftab720\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\s0
\f0\b0\fs26 \cf0 TODO}