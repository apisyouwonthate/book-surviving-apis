= Async

As a front-end developer, there are many different patterns that may be made available to you to read and write data asynchronously.  Like anything else, each has its benefits and challenges.  Your goal should be to make asynchronous interfaces feel like magic.  If implemented correctly, the people using your application won't feel burdened by waiting for data to come or go. They should feel confident that changes they're making are saved accurately.  When things go wrong, it should be easy for them to understand what broke, and what action they can take to remedy it (i.e. "Wait a moment and try again", or "You entered a title that is too long.").

Historically, there have been a variety of different ways to pull data from APIs asynchronously.  Included here are some of the more popular patterns that are in use today.

== Short Polling

In this scenario, you're asking a server for some information when something is ready.  That something can be anything - for the sake of example, let's imagine you're waiting to see if a credit card payment has succeeded.

In short polling, the client application asks the server for the information it's after at regular intervals, until that information comes back one way or another:

> Client: has this payment succeeded?
>
> Server: Not sure yet
>
> Client: has this payment succeeded?
> 
> Server: Not sure yet
>
> Client: has this payment succeeded?
> 
> Server: Not sure yet
>
> Client: has this payment succeeded?
> 
> Server: It did!

From an implementation standpoint, this usually looks like an indefinite loop of some sort, which is completed when we get the answer we want:

```javascript
const response = false;

const stopPolling = setInterval(pollServer, 500);

const pollServer = async () => {
  const results = fetch('https://some.api/cardpayment', options);
  if (results) stopPolling();
}

```

This is a very simple pattern, from the halcyon days of ajax requests.  While it does work, short polling is generally not a great approach for interface design for a few reasons: 

- It's a greedy strategy.  Sending lots of requests for one piece of data can use up battery life on mobile devices.

- It takes up precious thread space on your server. All API services have limits to how many requests they can process at once.  Crucially, short polling may work for one device at a time, but it doesn't scale well.

- Fallback and failure strategy is unclear. In other words, if the server _never_ changes its response from "Not sure yet", how do we know when to stop asking? What happens if your API client uses a different approach than another one, or if the server's response rules change?  

Right, so we don't like short polling too much.  What about...

== Long Polling

As you can imagine, this is similar to short polling, with one crucial difference: rather than asking over and over for the same information, the connection is left open until a response comes back from the server.  

> Client: Has this payment succeeded?
> 
> [some time later]
> 
> Server: Sure has!

This is a clear improvement on short-polling in the sense that the conversation is more succinct.  Your application doesn't need to fire off requests to the server every _X milliseconds_ until you get the information you're after.

So, what's the down side? Well - it's actually similar to the problem that short polling creates.  While a long polling approach doesn't send dozens of requests to the server throughout its lifecycle, it does fully occupy an API server thread until its request is complete.  If the server response is anything slower than _pretty much instant_, this approach runs into scaling problems very quickly, too.

From a UI design standpoint, it's particularly weak to connectivity problems.  If your LTE connection drops out while you're waiting for a response from a long-poll connection, it can be difficult to detect and properly recover from.

Long polling can also be catastrophically bad for user experience if you're asking for lots of information at once.  App developers who don't know better might send one single long poll request to their API for all the data needed for a given page.  Often this means that the entire interface is blank and showing as loading while heaps of information come back from the server. As we discussed in the UX pitfalls chapter, a better approach would be to split your API queries according to the logical hierarchy on screen, so you can get API data back in order of importance for that interface.

Generally speaking, it's best to stay away from long polling unless you're asking for a tiny bit of information which you know won't take a ton of processing power to return.

== Websockets

It turns out the answer to a lot of our problems comes in the form of websockets.  Under the hood, websockets are a protocol that is _parallel_ to `http`.  Websocket connections are established from client -> server via TCP.  That connection is then used as a direct line of communication between your client and the server for (effectively) as long as it's needed.  This gets around many of the problems already discussed in this chapter.

Websocket connections are flexible, and designed provide features that many  modern-day web applications use. 

In fact, there are plenty of websocket-enabled client/server tools and adaptations which you may already use at some level.  
